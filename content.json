{"meta":{"title":"Red","subtitle":"�չ�һ��","description":"","author":"John Doe","url":"https://red568.github.io","root":"/"},"pages":[{"title":"about","date":"2023-11-11T14:13:12.000Z","updated":"2024-04-03T14:42:42.072Z","comments":true,"path":"about/index.html","permalink":"https://red568.github.io/about/index.html","excerpt":"","text":"关于我哈喽！欢迎来到我的世界~ 在这里，我会记录下自己的一些学习笔记、做题思路、复盘经历、个人感悟，这是我的小世界。 代码之路并不简单，难在坚持和钻研，我写这个博客的目的便是可以记录下自己的成长，并监督激励自己。 期待自己成为代码大佬的那天，那真是太酷啦！！！"},{"title":"about","date":"2024-04-01T06:11:35.000Z","updated":"2024-04-01T06:11:35.884Z","comments":true,"path":"about/index-1.html","permalink":"https://red568.github.io/about/index-1.html","excerpt":"","text":""}],"posts":[{"title":"算法练习--day4","slug":"算法练习-day4","date":"2024-04-07T09:10:35.000Z","updated":"2024-04-07T09:12:04.086Z","comments":true,"path":"2024/04/07/算法练习-day4/","link":"","permalink":"https://red568.github.io/2024/04/07/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-day4/","excerpt":"","text":"24.两两交换链表中的节点19.删除链表的倒数第N个节点面试题 02.07. 链表相交142.环形链表II","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法练习--day3","slug":"算法练习-day3","date":"2024-04-07T08:31:18.000Z","updated":"2024-04-07T09:09:59.524Z","comments":true,"path":"2024/04/07/算法练习-day3/","link":"","permalink":"https://red568.github.io/2024/04/07/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-day3/","excerpt":"","text":"203.移除链表元素题目： 分析：类似双指针移动元素的解题思路，per指针记录已经筛选过的节点的末尾，cur指向还未筛选过的指针的头部，如果cur的值&#x3D;&#x3D;var，则cur后移，否则per.next&#x3D;cur 注意：最后per后面的指针都应该舍弃掉 12345678910111213141516171819202122232425/** * 添加虚节点方式 * 时间复杂度 O(n) * 空间复杂度 O(1) */class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; ListNode vHead=new ListNode(-1);//虚拟头部 ListNode cur=head;//记录当前比较的节点 ListNode per=vHead;//记录不为val的节点 while(cur!=null)&#123; //如果当前cur节点值==val，则这个节点舍弃，cur后移 if(cur.val==val)&#123; cur=cur.next; continue; &#125; //如果当前cur节点值1=val，则这个节点给per.next，两个指针后移 per.next=cur; cur=cur.next; per=per.next; &#125; per.next=null;//最后只要以per为末尾的那段链表，其他舍弃 return vHead.next; &#125;&#125; 707.设计链表题目： 分析： 由于需要涉及部分 index 相关操作，因此我们可以实现一个「双向链表」，同时使用变量 sz 记录下当前链表的总长度，这样在涉及 index 操作时，可从较近的一边出发遍历，剩下的则是常规的链表节点操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class MyLinkedList &#123; class Node &#123; Node prev, next; int val; Node (int _val) &#123; val = _val; &#125; &#125; Node he = new Node(-1), ta = new Node(-1); int sz = 0; public MyLinkedList() &#123; he.next = ta; ta.prev = he; &#125; public int get(int index) &#123; Node node = getNode(index); return node == null ? -1 : node.val; &#125; public void addAtHead(int val) &#123; Node node = new Node(val); node.next = he.next; node.prev = he; he.next.prev = node; he.next = node; sz++; &#125; public void addAtTail(int val) &#123; Node node = new Node(val); node.prev = ta.prev; node.next = ta; ta.prev.next = node; ta.prev = node; sz++; &#125; public void addAtIndex(int index, int val) &#123; if (index &gt; sz) return ; if (index &lt;= 0) &#123; addAtHead(val); &#125; else if (index == sz) &#123; addAtTail(val); &#125; else &#123; Node node = new Node(val), cur = getNode(index); node.next = cur; node.prev = cur.prev; cur.prev.next = node; cur.prev = node; sz++; &#125; &#125; public void deleteAtIndex(int index) &#123; Node cur = getNode(index); if (cur == null) return ; cur.next.prev = cur.prev; cur.prev.next = cur.next; sz--; &#125; Node getNode(int index) &#123; boolean isLeft = index &lt; sz / 2; if (!isLeft) index = sz - index - 1; for (Node cur = isLeft ? he.next : ta.prev; cur != ta &amp;&amp; cur != he; cur = isLeft ? cur.next : cur.prev) &#123; if (index-- == 0) return cur; &#125; return null; &#125;&#125; 206.反转链表题目： 分析：改变一下指针的方向就行 123456789101112131415public ListNode reverseList(ListNode head) &#123; if(head==null || head.next==null)&#123; return head; &#125; ListNode left=head; ListNode right=head.next; while(right!=null)&#123; ListNode tmp=right.next; right.next=left; left=right; right=tmp; &#125; head.next=null;//千万别忘了把头节点的next指针释放，否则会有循环链表出现 return left;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法练习--day2","slug":"算法练习-day2","date":"2024-04-07T07:57:37.000Z","updated":"2024-04-07T08:18:31.099Z","comments":true,"path":"2024/04/07/算法练习-day2/","link":"","permalink":"https://red568.github.io/2024/04/07/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-day2/","excerpt":"","text":"977.有序数组的平方题目： 分析： 最大值一定出现在两端，用双指针分别指向首尾两端，取平方的最大值放入新数组中最后倒序一下即可(或者直接倒序存入新数组也行) 1234567891011121314151617181920212223242526class Solution &#123; public int[] sortedSquares(int[] nums) &#123; int left=0; int right=nums.length-1; int[] newNums=new int[nums.length]; int[] temp=new int[nums.length]; int idx=0; while(left&lt;=right)&#123; int a=0; if(nums[left]*nums[left]&gt;=nums[right]*nums[right])&#123; a=nums[left]*nums[left]; left++; &#125;else&#123; a=nums[right]*nums[right]; right--; &#125; temp[idx]=a; idx++; &#125; idx=0; for(int i=temp.length-1;i&gt;=0;i--)&#123; newNums[idx++]=temp[i]; &#125; return newNums; &#125;&#125; 209.长度最小的子数组题目： 分析： 滑动窗口解决 （1）向右移动右指针直到窗口中的数值和&gt;&#x3D;target （2）再向右移动左指针直到窗口中的数值和不满足&gt;&#x3D;target 重复(1)(2)过程，直到右指针到达数值末尾，最终结果取最短窗口长度即可 123456789101112131415class Solution &#123;// 滑动窗口 public int minSubArrayLen(int s, int[] nums) &#123; int left = 0;//开始指针 int sum = 0; int result = Integer.MAX_VALUE;//result记录子序列长度 for (int right = 0; right &lt; nums.length; right++) &#123;//right是终止指针 sum += nums[right]; while (sum &gt;= s) &#123; result = Math.min(result, right - left + 1); sum -= nums[left++];//left指针向右移动 &#125; &#125; return result == Integer.MAX_VALUE ? 0 : result; &#125;&#125; 59.螺旋矩阵II题目： 分析： 方法1：由外向内，一圈一圈的向内循环，一共n&#x2F;2圈 填充上行从左到右 填充右列从上到下 填充下行从右到左 填充左列从下到上 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int[][] generateMatrix(int n) &#123; int loop = 0; // 控制循环次数 int start = 0; // 每次循环的开始点(start, start)，每经过一圈循环，向内部移动一下 int[][] res = new int[n][n]; int count = 1; // 定义填充数字 int i, j; //1.填写外围数字 while (loop++ &lt; n / 2) &#123;//一共有n/2个圆（循环） // 判断边界后，loop从1开始 //左闭右开 // 1.1 模拟上侧从左到右，j变化 for (j = start; j &lt; n - loop; j++) &#123; res[start][j] = count++; &#125; // 1.2 模拟右侧从上到下,i变化 for (i = start; i &lt; n - loop; i++) &#123; res[i][j] = count++; &#125; //1.3 模拟下侧从右到左，j变化 for (; j &gt;= loop; j--) &#123; res[i][j] = count++; &#125; // 1.4 模拟左侧从下到上，i变化 for (; i &gt;= loop; i--) &#123; res[i][j] = count++; &#125; //移动循环起始点 start++; &#125; //2.填写最中心那个数字 if (n % 2 == 1) &#123; res[start][start] = count; &#125; return res; &#125;&#125; 方法2：设置边界值，每次迭代完后移动边界值 此题的解题思路可参考： 54. 螺旋矩阵 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int[][] generateMatrix(int n) &#123; int l=0; int r=n-1; int t=0; int b=n-1; int[][] res=new int[n][n]; int count=1; while(true)&#123; //上侧 for(int i=l;i&lt;=r;i++)&#123; res[t][i]=count++; &#125; if(++t&gt;b) break; //右侧 for(int i=t;i&lt;=b;i++)&#123; res[i][r]=count++; &#125; if(--r&lt;l) break; //下侧 for(int i=r;i&gt;=l;i-- )&#123; res[b][i]=count++; &#125; if(--b&lt;t) break; //左侧 for(int i=b;i&gt;=t;i--)&#123; res[i][l]=count++; &#125; if(++l&gt;r) break; &#125; return res; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法练习—day1","slug":"算法练习—day1","date":"2024-04-03T13:49:55.000Z","updated":"2024-04-03T14:29:44.088Z","comments":true,"path":"2024/04/03/算法练习—day1/","link":"","permalink":"https://red568.github.io/2024/04/03/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E2%80%94day1/","excerpt":"","text":"704. 二分查找题目： 题目分析： 左右指针分别为[left,right]，每次都取中间元素和目标值比较，再移动左右指针即可 注意： (1) [left,right]是闭区间，在边界条件下mid可以取值为left或者right (2) 循环时的判断条件为 while(left&lt;&#x3D;right)，这里’&#x3D;’符号不可丢 (3) 为了防止数据多大，mid&#x3D;left+(right-left)&#x2F;2; (4) 二分法不仅可以用来查找值，还可以用来查值范围、用法很灵活，可以写个专题，这里留个坑之后填 代码： 27. 移除元素题目： 题目分析： 双指针法，用left记录留下值的数组末尾的下一位，也是新值将要插入的位置；right遍历值，如果指向值等于val则不做操作，指向值不等于val，则将该值赋值给left 注： 283. 移动零 和这道题的解题思路类似 代码：","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"测试文章","slug":"测试文章","date":"2023-11-11T14:16:15.000Z","updated":"2023-11-11T14:24:23.734Z","comments":true,"path":"2023/11/11/测试文章/","link":"","permalink":"https://red568.github.io/2023/11/11/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/","excerpt":"","text":"测试测试大家东方红东方红阿斯顿回复","categories":[{"name":"Java","slug":"Java","permalink":"https://red568.github.io/categories/Java/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://red568.github.io/tags/%E6%B5%8B%E8%AF%95/"}]}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"},{"name":"Java","slug":"Java","permalink":"https://red568.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"测试","slug":"测试","permalink":"https://red568.github.io/tags/%E6%B5%8B%E8%AF%95/"}]}