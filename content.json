{"meta":{"title":"Red","subtitle":"�չ�һ��","description":"","author":"John Doe","url":"https://red568.github.io","root":"/"},"pages":[{"title":"about","date":"2023-11-11T14:13:12.000Z","updated":"2024-04-03T14:42:42.072Z","comments":true,"path":"about/index.html","permalink":"https://red568.github.io/about/index.html","excerpt":"","text":"关于我哈喽！欢迎来到我的世界~ 在这里，我会记录下自己的一些学习笔记、做题思路、复盘经历、个人感悟，这是我的小世界。 代码之路并不简单，难在坚持和钻研，我写这个博客的目的便是可以记录下自己的成长，并监督激励自己。 期待自己成为代码大佬的那天，那真是太酷啦！！！"},{"title":"about","date":"2024-04-01T06:11:35.000Z","updated":"2024-04-01T06:11:35.884Z","comments":true,"path":"about/index-1.html","permalink":"https://red568.github.io/about/index-1.html","excerpt":"","text":""}],"posts":[{"title":"算法训练--day11","slug":"算法训练-day11","date":"2024-04-15T15:08:18.000Z","updated":"2024-04-15T15:16:04.702Z","comments":true,"path":"2024/04/15/算法训练-day11/","link":"","permalink":"https://red568.github.io/2024/04/15/%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83-day11/","excerpt":"","text":"347.前 K 个高频元素 分析：优先队列来解决，存储int型map，&lt;值，出现频次&gt;，并按照出现频次排序 1234567891011121314151617class Solution &#123; public int[] topKFrequent(int[] nums, int k) &#123; Map&lt;Integer,Integer&gt; map =new HashMap&lt;&gt;(); for(Integer it:nums)&#123; map.put(it,map.getOrDefault(it,0)+1); &#125; PriorityQueue&lt;int[]&gt; que=new PriorityQueue&lt;&gt;((a,b)-&gt;b[1]-a[1]); for(Integer key:map.keySet())&#123; que.add(new int[]&#123;key,map.get(key)&#125;); &#125; int[] res=new int[k]; for(int i=0;i&lt;k;i++)&#123; res[i]=que.poll()[0]; &#125; return res; &#125;&#125; 239. 滑动窗口最大值 1","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法练习--day10","slug":"算法练习-day10","date":"2024-04-13T13:23:25.000Z","updated":"2024-04-13T14:52:35.697Z","comments":true,"path":"2024/04/13/算法练习-day10/","link":"","permalink":"https://red568.github.io/2024/04/13/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-day10/","excerpt":"","text":"20. 有效的括号 这种匹配情况可以用一个map记录下映射关系，在结果栈来实现左右括号的匹配 12345678910111213141516171819202122232425262728class Solution &#123; public boolean isValid(String s) &#123; Deque&lt;Character&gt; stack=new LinkedList&lt;&gt;(); Map&lt;Character,Character&gt; map=new HashMap&lt;&gt;(); map.put(&#x27;)&#x27;,&#x27;(&#x27;); map.put(&#x27;&#125;&#x27;,&#x27;&#123;&#x27;); map.put(&#x27;]&#x27;,&#x27;[&#x27;); for(int i=0;i&lt;s.length();i++)&#123; if(s.charAt(i)==&#x27;)&#x27;||s.charAt(i)==&#x27;&#125;&#x27;||s.charAt(i)==&#x27;]&#x27;)&#123; if(!stack.isEmpty())&#123; if(stack.pop()!=map.get(s.charAt(i))) return false; &#125;else&#123; return false; &#125; &#125;else&#123; stack.push(s.charAt(i)); &#125; &#125; if(stack.isEmpty())&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125; 1047. 删除字符串中的所有相邻重复项 栈的另一个作用可以去除字符串中的相邻重复项 1234567891011121314151617181920212223class Solution &#123; public String removeDuplicates(String s) &#123; Deque&lt;Character&gt; stack=new LinkedList&lt;&gt;(); for(int i=0;i&lt;s.length();i++)&#123; char ch=s.charAt(i); if((!stack.isEmpty())&amp;&amp;stack.peek()==ch)&#123; //需要循环 while(!stack.isEmpty()&amp;&amp;stack.peek()==ch)&#123; stack.pop(); &#125; &#125;else&#123; stack.push(ch); &#125; &#125; //需注意，随后栈的元素是倒序的，需要处理一下 char[] res=new char[stack.size()]; int index=stack.size()-1; while(!stack.isEmpty())&#123; res[index--]=stack.pop(); &#125; return new String(res); &#125;&#125; 150. 逆波兰表达式求值 遇到数字就入栈 遇到运算符就出栈两个元素进行计算，将计算结果入栈，注意 -和&#x2F;有运算顺序 123456789101112131415161718192021class Solution &#123; public int evalRPN(String[] tokens) &#123; Deque&lt;Integer&gt; stack = new LinkedList(); for (String s : tokens) &#123; if (&quot;+&quot;.equals(s)) &#123; // leetcode 内置jdk的问题，不能使用==判断字符串是否相等 stack.push(stack.pop() + stack.pop()); &#125; else if (&quot;-&quot;.equals(s)) &#123;// 注意 - 和/ 需要特殊处理，注意顺序，后出栈的是被减数 stack.push(-stack.pop() + stack.pop()); &#125; else if (&quot;*&quot;.equals(s)) &#123; stack.push(stack.pop() * stack.pop()); &#125; else if (&quot;/&quot;.equals(s)) &#123;//必须用双引号，因为为字符串形式，后出栈的是被除数 int temp1 = stack.pop(); int temp2 = stack.pop(); stack.push(temp2 / temp1); &#125; else &#123; stack.push(Integer.valueOf(s));//需要转换为int值才能放进栈 &#125; &#125; return stack.pop(); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法练习--day9","slug":"算法练习-day9","date":"2024-04-12T06:01:32.000Z","updated":"2024-04-12T06:53:19.517Z","comments":true,"path":"2024/04/12/算法练习-day9/","link":"","permalink":"https://red568.github.io/2024/04/12/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-day9/","excerpt":"","text":"232.用栈实现队列 分析： 两个栈模拟一个队列，一个栈A用于模拟进栈，出栈时，需要将栈A中的元素先导入栈B中，再出栈即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class MyQueue &#123; //要先声明，再在构建方法中实例化 Deque&lt;Integer&gt; stack1=null; Deque&lt;Integer&gt; stack2=null; public MyQueue() &#123; stack1=new LinkedList&lt;&gt;(); stack2=new LinkedList&lt;&gt;(); &#125; //进队，直接再栈1中加入就好 public void push(int x) &#123; stack1.push(x); &#125; //出队，如果栈2中有元素，就直接出栈 //如果栈2为空，先将栈1的元素导入栈2，再出栈 public int pop() &#123; if(!stack2.isEmpty())&#123; return stack2.pop(); &#125;else&#123; while(!stack1.isEmpty())&#123; stack2.push(stack1.pop()); &#125; return stack2.pop(); &#125; &#125; //逻辑等同出队 public int peek() &#123; if(!stack2.isEmpty())&#123; return stack2.peek(); &#125;else&#123; while(!stack1.isEmpty())&#123; stack2.push(stack1.pop()); &#125; return stack2.peek(); &#125; &#125; //判断为空：栈1和栈2都为空 public boolean empty() &#123; return stack1.isEmpty()&amp;&amp;stack2.isEmpty(); &#125;&#125;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */ 225. 用队列实现栈 分析：一个队列作为备份，保证后加元素加在队头位置 12345678910111213141516171819202122232425262728293031323334353637//用两个queue实现class MyStack &#123; Queue&lt;Integer&gt; queue1; // 和栈中保持一样元素的队列 Queue&lt;Integer&gt; queue2; // 辅助队列 //初始化 public MyStack() &#123; queue1 = new LinkedList&lt;&gt;(); queue2 = new LinkedList&lt;&gt;(); &#125; //增,先加到que1中，把que2中的元素copy到que1中，实现后进先出的元素在顶部 //交换que1,que2的角色，继续实现 public void push(int x) &#123; queue2.offer(x); // 先放在辅助队列中 while (!queue1.isEmpty())&#123;//将que1中的元素加在后面 queue2.offer(queue1.poll()); &#125; // 最后交换queue1和queue2，将元素都放到queue1中 Queue&lt;Integer&gt; queueTemp; queueTemp = queue1; queue1 = queue2; queue2 = queueTemp; &#125; //删 public int pop() &#123; return queue1.poll(); // 因为queue1中的元素和栈中的保持一致，所以这个和下面两个的操作只看queue1即可 &#125; //取top元素 public int top() &#123; return queue1.peek(); &#125; //判断是否为空 public boolean empty() &#123; return queue1.isEmpty(); &#125;&#125; 123456789101112131415161718192021222324//优化，用一个queue实现class MyStack &#123; Queue&lt;Integer&gt; queue; public MyStack() &#123; queue = new LinkedList&lt;&gt;(); &#125; //每 offer 一个数（A）进来，都重新排列，把这个数（A）放到队列的队首 public void push(int x) &#123; queue.offer(x); int size = queue.size(); //移动除了 A 的其它数 while (size-- &gt; 1) queue.offer(queue.poll()); &#125; public int pop() &#123; return queue.poll(); &#125; public int top() &#123; return queue.peek(); &#125; public boolean empty() &#123; return queue.isEmpty(); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法练习-day8","slug":"算法练习-day8","date":"2024-04-11T17:04:40.000Z","updated":"2024-04-12T07:53:49.848Z","comments":true,"path":"2024/04/12/算法练习-day8/","link":"","permalink":"https://red568.github.io/2024/04/12/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-day8/","excerpt":"","text":"28. 实现 strStr() 分析： KMP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 减一实现//j 和 next[j]可以互相表示//数组中都必须+1 [j+1] //长度减一 ： j == needle.length()-1class Solution &#123; //获得next指针的逻辑 public void getNext(int[] next, String s)&#123;//把next传参进去了 //初始化，j是前缀的末尾，i是后缀的末尾 int j = -1; next[0] = j; //进行遍历，后缀慢慢后移遍历 for (int i = 1; i &lt; s.length(); i++)&#123; //i ，j指向元素大小不同的情况，回退 //为什么要添加j&gt;=0的条件?-1的就不要再遍历了，-1是第一个元素到头了，避免死循环 while(j &gt;= 0 &amp;&amp; s.charAt(i) != s.charAt(j+1))&#123; j=next[j];//要比较的前缀末尾 回退到 以 j为后缀指针的对称前缀的末尾 &#125; if(s.charAt(i) == s.charAt(j+1))&#123;//如果元素值相等 j++;//前缀末尾指针后移（相同的前后缀长度+1） &#125; next[i] = j;//记录前缀的长度-1，也就是相同的前后缀长度 &#125; &#125; //业务逻辑 public int strStr(String haystack, String needle) &#123; if(needle.length()==0)&#123; return 0; &#125; //定义获取next数组 int[] next = new int[needle.length()]; getNext(next, needle); int j = -1; //遍历，i指针指向文本串，j指向可以回退的模式串,注意这里从o开始 for(int i = 0; i &lt; haystack.length(); i++)&#123; //对应位置不等，回退，回退逻辑与next数组中的相同 while(j&gt;=0 &amp;&amp; haystack.charAt(i) != needle.charAt(j+1))&#123; j = next[j]; &#125; //对应位置相同，j后移 if(haystack.charAt(i) == needle.charAt(j+1))&#123; j++; &#125; //模式串到底则结束 if(j == needle.length()-1)&#123; return (i-needle.length()+1); &#125; &#125; return -1; &#125; 459.重复的子字符串 KMP字符串匹配： 最长相等前后缀的长度为：next[len - 1] + 1&#x3D;&#x3D;》即图中，数字0-7的位置， 重复字符串的长度 ： len - (next[len - 1] + 1)&#x3D;&#x3D;》即图中，-1的数组的长度 如果len % (len - (next[len - 1] + 1)) &#x3D;&#x3D; 0 ，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。 12345678910111213141516171819202122232425262728class Solution &#123; public boolean repeatedSubstringPattern(String s) &#123; //判断空条件 if(s==null ||s.equals(&quot;&quot;))&#123; return false; &#125; int len = s.length(); int next[] = new int[len]; int j=-1; next[0] = -1; //获得next数组的逻辑 for(int i=1; i&lt; s.length() ; i++)&#123; while(j&gt;=0 &amp;&amp; s.charAt(i) != s.charAt(j+1))&#123; j=next[j]; &#125; if( s.charAt(i) == s.charAt(j+1))&#123; j++; &#125; next[i] = j; &#125; //判断，注意必须next[len-1] &gt;= 0 ==&gt; if(next[len-1] &gt;= 0 &amp;&amp;len % (len - (next[len-1]+1))==0)&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法练习--day7","slug":"算法练习-day7","date":"2024-04-10T07:48:32.000Z","updated":"2024-04-11T16:59:24.647Z","comments":true,"path":"2024/04/10/算法练习-day7/","link":"","permalink":"https://red568.github.io/2024/04/10/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-day7/","excerpt":"","text":"344.反转字符串 分析： 双指针，两头向中间遍历，一边遍历一边交换元素 1234567891011121314class Solution &#123; public void reverseString(char[] s) &#123; int left=0; int right=s.length-1; while(left&lt;right)&#123; char temp=s[left]; s[left] =s[right]; s[right]=temp; left++; right--; &#125; &#125;&#125; 541. 反转字符串II 分析： 在反转字符串基础上增加一个2k的条件，在遍历字符串的过程中，只要让 i +&#x3D; (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。 12345678910111213141516171819class Solution &#123; public String reverseStr(String s, int k) &#123; char[] ch = s.toCharArray(); for(int i = 0; i &lt; ch.length; i += 2 * k)&#123; int start = i; //这里是判断尾数够不够k个来取决end指针的位置 int end = Math.min(ch.length - 1, start + k - 1); //用异或运算反转 while(start &lt; end)&#123; ch[start] ^= ch[end]; ch[end] ^= ch[start]; ch[start] ^= ch[end]; start++; end--; &#125; &#125; return new String(ch); &#125;&#125; 卡码网：54.替换数字 分析： 新增一个StringBuffer承接一下，如果是字母，则正常copy过来，如果是数字，则追加number字符串 1234567891011121314151617import java.util.*;class Main&#123; public static void main(String[] args)&#123; Scanner in=new Scanner(System.in); String str=in.next(); StringBuffer res=new StringBuffer(); for(int i=0;i&lt;str.length();i++)&#123; if(str.charAt(i)&gt;=&#x27;a&#x27; &amp;&amp; str.charAt(i)&lt;=&#x27;z&#x27;)&#123; res.append(str.charAt(i)); &#125;else&#123; res.append(&quot;number&quot;); &#125; &#125; System.out.println(res.toString()); &#125; &#125; 151.翻转字符串里的单词 分析： 1.先划分出每个单词，并在单词内部反转，将位置和单词保存在map中 2.倒序组装单词 注意： 注意处理前导空格，后导空格，中间多余空格的情况 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public String reverseWords(String s) &#123; //&lt;序号+1,单词&gt; Map&lt;Integer,String&gt; map=new HashMap(); //单词个数 int num=0; //1.拆分出单词来，并把单词内部倒序 //注意处理 前导空格、尾随空格或者单词间的多个空格 StringBuffer str=new StringBuffer(); for(int i=0;i&lt;s.length();i++)&#123; //前导空格处理和中间多空格处理 if(str.toString().equals(&quot;&quot;)&amp;&amp;s.charAt(i)==&#x27; &#x27;)&#123; continue; &#125; if(s.charAt(i)!=&#x27; &#x27;)&#123; str.append(s.charAt(i)); &#125;else if(s.charAt(i)==&#x27; &#x27;)&#123; num++; map.put(num,str.toString());//这里一定要转为string，不然是浅拷贝，数值会变 str.setLength(0); &#125; &#125; //如果最后一个单词没有空格分隔，，最后一个单词就少了，别忘了也加上 if(s.charAt(s.length()-1)!=&#x27; &#x27;)&#123; num++; map.put(num,str.toString()); &#125; //2.按照倒序组装一下单词 str.setLength(0); for(int i=num;i&gt;1;i--)&#123; str.append(map.get(i)); str.append(&#x27; &#x27;); &#125; //在最后一个位置组装上第一个单词（少一个空格） str.append(map.get(1)); return str.toString(); &#125;&#125; 卡码网：55.右旋转字符串 分析： （1）先把后k个元素copy过来 （2）再把剩余的元素copy过来 1234567891011121314151617import java.util.*;class Main&#123; public static void main(String[] args)&#123; Scanner in =new Scanner(System.in); int k=in.nextInt(); String str=in.next(); StringBuffer stringBuffer=new StringBuffer(); int len=str.length(); for(int i=len-k;i&lt;len;i++)&#123; stringBuffer.append(str.charAt(i)); &#125; for(int i=0;i&lt;len-k;i++)&#123; stringBuffer.append(str.charAt(i)); &#125; System.out.println(stringBuffer.toString()); &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法练习-day6","slug":"算法练习-day6","date":"2024-04-09T14:55:28.000Z","updated":"2024-04-09T15:43:16.047Z","comments":true,"path":"2024/04/09/算法练习-day6/","link":"","permalink":"https://red568.github.io/2024/04/09/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-day6/","excerpt":"","text":"454.四数相加II 注意：区分求一个数组中的四数之和！这是四个数组，不能用双指针 分析：和两数之和的处理逻辑相同，不过是需要将两个数组合并为一组 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。 两个for循环遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。 1234567891011121314151617181920class Solution &#123; public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); int res=0; for(int t1:nums1)&#123; for(int t2:nums2)&#123; map.put(t1+t2,map.getOrDefault(t1+t2,0)+1); &#125; &#125; for(int t3:nums3)&#123; for(int t4:nums4)&#123; int temp=-(t3+t4); if(map.containsKey(temp))&#123; res+=map.get(temp); &#125; &#125; &#125; return res; &#125;&#125; 383. 赎金信 用两个map分别记录下两个字符串中的字符+出现频次 遍历map1的key，保证map2中含这些key，并且频次大于map1的 12345678910111213141516171819class Solution &#123; public boolean canConstruct(String ransomNote, String magazine) &#123; Map&lt;Character,Integer&gt; map1=new HashMap&lt;&gt;(); Map&lt;Character,Integer&gt; map2=new HashMap&lt;&gt;(); for(int i=0;i&lt;ransomNote.length();i++)&#123; map1.put(ransomNote.charAt(i),map1.getOrDefault(ransomNote.charAt(i),0)+1); &#125; for(int i=0;i&lt;magazine.length();i++)&#123; map2.put(magazine.charAt(i),map2.getOrDefault(magazine.charAt(i),0)+1); &#125; for(Character it:map1.keySet())&#123; if(map2.getOrDefault(it,0)&lt;map1.get(it))&#123; return false; &#125; &#125; return true; &#125;&#125; 15. 三数之和 分析：对数组排序+一个for循环+双指针+去重操作 先将数组排序。三个指针，固定一个指针k，其余两个指针ij进行双指针遍历就行 k&#x3D;0开始循环遍历，i，j为[k+1 , length-1]这段范围的数组 nums[k]&gt;0，则三个数之和肯定大于0，break&#x3D;&#x3D;&gt;节约时间 去重nums[k] &#x3D;&#x3D; num[k-1] ，则当前k与前一个数重复，直接跳过（否则会出现重复组合），一定是k-1进行比较，因为后一个数和前一个数比较，否则会出问题 之后while(i&lt;j)， 如果，sum&gt;0 ,则 j 需要左移，并且不仅仅要移动一下，要移动至下一个更小的数，因此加一个循环while(i &lt; j &amp;&amp; nums[j] &#x3D;&#x3D; nums[–j]); 同理，sum&lt;0，则 i 需要右移，while(i &lt; j &amp;&amp; nums[i] &#x3D;&#x3D; nums[++i]); 如果，sum&#x3D;0，满足条件，加入到结果集中，并且i j 需要同时向内移动， 如何去重？ a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right] a 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。 但这里有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。这两个不一样！！！例如{-1, -1 ,2} 这组数据，如果第一种去重方法就直接排除了，应该向前比较，因为前一个重复的元素已经记录下这种情况了，这里只需要除去就行 b c重复的话怎么办，直接跳过下一个 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); int n=nums.length; List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;(); for(int i=0;i&lt;=n-3;i++)&#123; //短路操作 if (nums[i] &gt; 0) &#123; return res; &#125; //a 去重操作 if(i&gt;0&amp;&amp;nums[i]==nums[i-1])&#123; continue; &#125; int left=i+1; int right=n-1; while(left&lt;right)&#123; int sum=nums[left]+nums[right]+nums[i]; if(sum==0)&#123; List&lt;Integer&gt; ls=new ArrayList(); ls.add(nums[i]); ls.add(nums[left]); ls.add(nums[right]); res.add(ls); // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重 while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--; while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++; right--; left++; &#125;else if(sum&lt;0)&#123; left++; &#125;else if(sum&gt;0)&#123; right--; &#125; &#125; &#125; return res; &#125;&#125; 18. 四数之和 分析：在三数之和的基础上多加了一个for循环，注意去重问题 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); Arrays.sort(nums);//第一层循环 for(int i = 0 ; i&lt;nums.length; i++)&#123; //短路 if( nums[i] &gt; 0 &amp;&amp; nums[i] &gt; target ) return result; //去重 if(i&gt;0 &amp;&amp; nums[i] == nums[i - 1]) continue; //第二层循环 for(int j = i+ 1 ; j&lt;nums.length ; j++)&#123; //去重 if(j &gt; i+1 &amp;&amp; nums[j] == nums[j - 1])&#123; continue; &#125; int left = j + 1; int right = nums.length - 1; while(left &lt; right)&#123; int sum = nums[i] + nums[j] + nums[left] + nums[right]; if(sum &gt; target)&#123; while(left&lt;right &amp;&amp; nums[right]==nums[--right]); &#125;else if(sum &lt; target)&#123; while(left&lt;right &amp;&amp; nums[left]==nums[++left]); &#125;else&#123; result.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right])); while(left&lt;right &amp;&amp; nums[right]==nums[--right]); while(left&lt;right &amp;&amp; nums[left]==nums[++left]); &#125; &#125; &#125; &#125; return result; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法练习--day5","slug":"算法练习-day5","date":"2024-04-08T12:02:36.000Z","updated":"2024-04-08T13:24:45.770Z","comments":true,"path":"2024/04/08/算法练习-day5/","link":"","permalink":"https://red568.github.io/2024/04/08/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-day5/","excerpt":"","text":"242.有效的字母异位词 分析： (1)用map1和map2分别记录下s&#x2F;t出现的字符+出现频次 (2)最后比较两个map是否相同 123456789101112131415161718class Solution &#123; public boolean isAnagram(String s, String t) &#123; int lens=s.length(); int lent=t.length(); if(lens!=lent)&#123; return false; &#125; Map&lt;Character,Integer&gt; map_s = new HashMap&lt;&gt;(); Map&lt;Character,Integer&gt; map_t = new HashMap&lt;&gt;(); for(int i=0;i&lt;lens;i++)&#123; map_s.put(s.charAt(i),map_s.getOrDefault(s.charAt(i),0)+1); map_t.put(t.charAt(i),map_t.getOrDefault(t.charAt(i),0)+1); &#125; return map_s.equals(map_t); &#125;&#125; 349.两个数组的交集 分析： （1）用set1存储num1的元素并去重 （2）遍历num2，判断元素是否在set1中出现，如果出现则放入set2中（为什么这里要用一个set2呢，因为num2本身的元素可能有重复的,用set2再次去重一遍） 1234567891011121314151617181920212223class Solution &#123; public int[] intersection(int[] nums1, int[] nums2) &#123; int n1=nums1.length; int n2=nums2.length; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); Set&lt;Integer&gt; res = new HashSet&lt;&gt;(); for(int i=0;i&lt;n1;i++)&#123; set.add(nums1[i]); &#125; for(int i=0;i&lt;n2;i++)&#123; if(set.contains(nums2[i]))&#123; res.add(nums2[i]); &#125; &#125; int[] arr=new int[res.size()]; int index=0; for(Integer it:res)&#123; arr[index]=it; index++; &#125; return arr; &#125;&#125; 202.快乐数 分析： （1）如果n不是快乐数，则res数值会无限循环出现 （2）用set记录下计算的res，如果出现重复数据则不是快乐数，如果res&#x3D;1，则为快乐数 1234567891011121314151617181920212223class Solution &#123; public boolean isHappy(int n) &#123; //set记录出现过的sum（即n） Set&lt;Integer&gt; record = new HashSet&lt;&gt;(); //当n不为1时并且set中不包含n时继续遍历，set中不包含n保证只循环一遍，避免无限循环下去 while (n != 1 &amp;&amp; !record.contains(n)) &#123; record.add(n); n = getNextNumber(n);//进行计算后的sum &#125; return n == 1; &#125; private int getNextNumber(int n) &#123; int res = 0; //依次取最后一位，进行平方和 while (n &gt; 0) &#123; int temp = n % 10;//取最后一位 res += temp * temp;//加上其平方 n = n / 10;//去除最后一位 &#125; return res; &#125;&#125; 1.两数之和 分析：哈希解决，判断条件为a+b&#x3D;target 变形一下：b&#x3D;a-target （1）遍历每一个nums[i], （2）并检查 target-nums[i] 是否在map中， （3）如果不在，则nums[i]和下标存入map中， （4）如果在，将两个下标存在放入结果集中 123456789101112131415161718class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;(); int[] res=new int[2]; for(int i=0;i&lt;nums.length;i++)&#123; int cur=nums[i]; int temp=target-cur; if(map.containsKey(temp))&#123; res[0]=map.get(temp); res[1]=i; return res; &#125;else&#123; map.put(cur,i); &#125; &#125; return new int[0]; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法练习--day4","slug":"算法练习-day4","date":"2024-04-07T09:10:35.000Z","updated":"2024-04-07T14:22:03.435Z","comments":true,"path":"2024/04/07/算法练习-day4/","link":"","permalink":"https://red568.github.io/2024/04/07/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-day4/","excerpt":"","text":"24.两两交换链表中的节点题目： 分析： 每两个节点做一个交换，用虚拟节点更便捷 12345678910111213141516171819202122232425class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head==null ||head.next==null)&#123; return head; &#125; ListNode vHead=new ListNode(-1); ListNode per=vHead; ListNode left=head; ListNode right=head.next; while(right!=null)&#123; ListNode tempa=right.next; ListNode tempb=null; if(tempa!=null)&#123; tempb=right.next.next; &#125; per.next=right; right.next=left; left.next=tempa; per=left; left=tempa; right=tempb; &#125; return vHead.next; &#125;&#125; 19.删除链表的倒数第N个节点题目： 分析： 快慢指针，只要快慢指针相差 n 个结点即可，用于定位倒数第n个节点 &#x2F;&#x2F;注意这里用到了虚拟头节点，用虚拟头节点来构建一个新链表—因为删除可能涉及到旧链表头节点，所以用虚拟头节点最好 12345678910111213141516171819class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode vHead=new ListNode(-1); vHead.next=head; ListNode per=vHead; ListNode node=head; ListNode cur=head; for(int i=0;i&lt;n;i++)&#123; cur=cur.next; &#125; while(cur!=null)&#123; cur=cur.next; node=node.next; per=per.next; &#125; per.next=node.next; return vHead.next; &#125;&#125; 160. 链表相交 两个链表长度不相同：让长度更长的链表指针后移，直到长度相同，再求相交的链表节点 1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; int lenA=0; int lenB=0; ListNode a=headA; ListNode b=headB; while(a!=null)&#123; a=a.next; lenA++; &#125; while(b!=null)&#123; b=b.next; lenB++; &#125; if(lenA&gt;lenB)&#123; b=headB; a=headA; int i=0; while(i&lt;lenA-lenB)&#123; a=a.next; i++; &#125; &#125;else&#123; b=headB; a=headA; int i=0; while(i&lt;lenB-lenA)&#123; b=b.next; i++; &#125; &#125; while(a!=null)&#123; if(a.equals(b))&#123; return a; &#125; a=a.next; b=b.next; &#125; return null; &#125;&#125; 142.环形链表II x+y&#x3D;y+z 可推导出 x&#x3D;z，因此找到快慢指针相遇的点，在头节点放置一个新指针，再次相遇的位置就是环的入口 123456789101112131415161718192021public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; ListNode fast=head; ListNode slow=head; while(fast!=null &amp;&amp;fast.next!=null)&#123; fast=fast.next.next; slow=slow.next; if(fast==slow)&#123; ListNode cur=head; while(true)&#123; if(cur==slow)&#123; return cur; &#125; cur=cur.next; slow=slow.next; &#125; &#125; &#125; return null; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法练习--day3","slug":"算法练习-day3","date":"2024-04-07T08:31:18.000Z","updated":"2024-04-07T09:09:59.524Z","comments":true,"path":"2024/04/07/算法练习-day3/","link":"","permalink":"https://red568.github.io/2024/04/07/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-day3/","excerpt":"","text":"203.移除链表元素题目： 分析：类似双指针移动元素的解题思路，per指针记录已经筛选过的节点的末尾，cur指向还未筛选过的指针的头部，如果cur的值&#x3D;&#x3D;var，则cur后移，否则per.next&#x3D;cur 注意：最后per后面的指针都应该舍弃掉 12345678910111213141516171819202122232425/** * 添加虚节点方式 * 时间复杂度 O(n) * 空间复杂度 O(1) */class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; ListNode vHead=new ListNode(-1);//虚拟头部 ListNode cur=head;//记录当前比较的节点 ListNode per=vHead;//记录不为val的节点 while(cur!=null)&#123; //如果当前cur节点值==val，则这个节点舍弃，cur后移 if(cur.val==val)&#123; cur=cur.next; continue; &#125; //如果当前cur节点值1=val，则这个节点给per.next，两个指针后移 per.next=cur; cur=cur.next; per=per.next; &#125; per.next=null;//最后只要以per为末尾的那段链表，其他舍弃 return vHead.next; &#125;&#125; 707.设计链表题目： 分析： 由于需要涉及部分 index 相关操作，因此我们可以实现一个「双向链表」，同时使用变量 sz 记录下当前链表的总长度，这样在涉及 index 操作时，可从较近的一边出发遍历，剩下的则是常规的链表节点操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class MyLinkedList &#123; class Node &#123; Node prev, next; int val; Node (int _val) &#123; val = _val; &#125; &#125; Node he = new Node(-1), ta = new Node(-1); int sz = 0; public MyLinkedList() &#123; he.next = ta; ta.prev = he; &#125; public int get(int index) &#123; Node node = getNode(index); return node == null ? -1 : node.val; &#125; public void addAtHead(int val) &#123; Node node = new Node(val); node.next = he.next; node.prev = he; he.next.prev = node; he.next = node; sz++; &#125; public void addAtTail(int val) &#123; Node node = new Node(val); node.prev = ta.prev; node.next = ta; ta.prev.next = node; ta.prev = node; sz++; &#125; public void addAtIndex(int index, int val) &#123; if (index &gt; sz) return ; if (index &lt;= 0) &#123; addAtHead(val); &#125; else if (index == sz) &#123; addAtTail(val); &#125; else &#123; Node node = new Node(val), cur = getNode(index); node.next = cur; node.prev = cur.prev; cur.prev.next = node; cur.prev = node; sz++; &#125; &#125; public void deleteAtIndex(int index) &#123; Node cur = getNode(index); if (cur == null) return ; cur.next.prev = cur.prev; cur.prev.next = cur.next; sz--; &#125; Node getNode(int index) &#123; boolean isLeft = index &lt; sz / 2; if (!isLeft) index = sz - index - 1; for (Node cur = isLeft ? he.next : ta.prev; cur != ta &amp;&amp; cur != he; cur = isLeft ? cur.next : cur.prev) &#123; if (index-- == 0) return cur; &#125; return null; &#125;&#125; 206.反转链表题目： 分析：改变一下指针的方向就行 123456789101112131415public ListNode reverseList(ListNode head) &#123; if(head==null || head.next==null)&#123; return head; &#125; ListNode left=head; ListNode right=head.next; while(right!=null)&#123; ListNode tmp=right.next; right.next=left; left=right; right=tmp; &#125; head.next=null;//千万别忘了把头节点的next指针释放，否则会有循环链表出现 return left;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法练习--day2","slug":"算法练习-day2","date":"2024-04-07T07:57:37.000Z","updated":"2024-04-07T08:18:31.099Z","comments":true,"path":"2024/04/07/算法练习-day2/","link":"","permalink":"https://red568.github.io/2024/04/07/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-day2/","excerpt":"","text":"977.有序数组的平方题目： 分析： 最大值一定出现在两端，用双指针分别指向首尾两端，取平方的最大值放入新数组中最后倒序一下即可(或者直接倒序存入新数组也行) 1234567891011121314151617181920212223242526class Solution &#123; public int[] sortedSquares(int[] nums) &#123; int left=0; int right=nums.length-1; int[] newNums=new int[nums.length]; int[] temp=new int[nums.length]; int idx=0; while(left&lt;=right)&#123; int a=0; if(nums[left]*nums[left]&gt;=nums[right]*nums[right])&#123; a=nums[left]*nums[left]; left++; &#125;else&#123; a=nums[right]*nums[right]; right--; &#125; temp[idx]=a; idx++; &#125; idx=0; for(int i=temp.length-1;i&gt;=0;i--)&#123; newNums[idx++]=temp[i]; &#125; return newNums; &#125;&#125; 209.长度最小的子数组题目： 分析： 滑动窗口解决 （1）向右移动右指针直到窗口中的数值和&gt;&#x3D;target （2）再向右移动左指针直到窗口中的数值和不满足&gt;&#x3D;target 重复(1)(2)过程，直到右指针到达数值末尾，最终结果取最短窗口长度即可 123456789101112131415class Solution &#123;// 滑动窗口 public int minSubArrayLen(int s, int[] nums) &#123; int left = 0;//开始指针 int sum = 0; int result = Integer.MAX_VALUE;//result记录子序列长度 for (int right = 0; right &lt; nums.length; right++) &#123;//right是终止指针 sum += nums[right]; while (sum &gt;= s) &#123; result = Math.min(result, right - left + 1); sum -= nums[left++];//left指针向右移动 &#125; &#125; return result == Integer.MAX_VALUE ? 0 : result; &#125;&#125; 59.螺旋矩阵II题目： 分析： 方法1：由外向内，一圈一圈的向内循环，一共n&#x2F;2圈 填充上行从左到右 填充右列从上到下 填充下行从右到左 填充左列从下到上 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int[][] generateMatrix(int n) &#123; int loop = 0; // 控制循环次数 int start = 0; // 每次循环的开始点(start, start)，每经过一圈循环，向内部移动一下 int[][] res = new int[n][n]; int count = 1; // 定义填充数字 int i, j; //1.填写外围数字 while (loop++ &lt; n / 2) &#123;//一共有n/2个圆（循环） // 判断边界后，loop从1开始 //左闭右开 // 1.1 模拟上侧从左到右，j变化 for (j = start; j &lt; n - loop; j++) &#123; res[start][j] = count++; &#125; // 1.2 模拟右侧从上到下,i变化 for (i = start; i &lt; n - loop; i++) &#123; res[i][j] = count++; &#125; //1.3 模拟下侧从右到左，j变化 for (; j &gt;= loop; j--) &#123; res[i][j] = count++; &#125; // 1.4 模拟左侧从下到上，i变化 for (; i &gt;= loop; i--) &#123; res[i][j] = count++; &#125; //移动循环起始点 start++; &#125; //2.填写最中心那个数字 if (n % 2 == 1) &#123; res[start][start] = count; &#125; return res; &#125;&#125; 方法2：设置边界值，每次迭代完后移动边界值 此题的解题思路可参考： 54. 螺旋矩阵 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int[][] generateMatrix(int n) &#123; int l=0; int r=n-1; int t=0; int b=n-1; int[][] res=new int[n][n]; int count=1; while(true)&#123; //上侧 for(int i=l;i&lt;=r;i++)&#123; res[t][i]=count++; &#125; if(++t&gt;b) break; //右侧 for(int i=t;i&lt;=b;i++)&#123; res[i][r]=count++; &#125; if(--r&lt;l) break; //下侧 for(int i=r;i&gt;=l;i-- )&#123; res[b][i]=count++; &#125; if(--b&lt;t) break; //左侧 for(int i=b;i&gt;=t;i--)&#123; res[i][l]=count++; &#125; if(++l&gt;r) break; &#125; return res; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法练习—day1","slug":"算法练习—day1","date":"2024-04-03T13:49:55.000Z","updated":"2024-04-03T14:29:44.088Z","comments":true,"path":"2024/04/03/算法练习—day1/","link":"","permalink":"https://red568.github.io/2024/04/03/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E2%80%94day1/","excerpt":"","text":"704. 二分查找题目： 题目分析： 左右指针分别为[left,right]，每次都取中间元素和目标值比较，再移动左右指针即可 注意： (1) [left,right]是闭区间，在边界条件下mid可以取值为left或者right (2) 循环时的判断条件为 while(left&lt;&#x3D;right)，这里’&#x3D;’符号不可丢 (3) 为了防止数据多大，mid&#x3D;left+(right-left)&#x2F;2; (4) 二分法不仅可以用来查找值，还可以用来查值范围、用法很灵活，可以写个专题，这里留个坑之后填 代码： 27. 移除元素题目： 题目分析： 双指针法，用left记录留下值的数组末尾的下一位，也是新值将要插入的位置；right遍历值，如果指向值等于val则不做操作，指向值不等于val，则将该值赋值给left 注： 283. 移动零 和这道题的解题思路类似 代码：","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"测试文章","slug":"测试文章","date":"2023-11-11T14:16:15.000Z","updated":"2023-11-11T14:24:23.734Z","comments":true,"path":"2023/11/11/测试文章/","link":"","permalink":"https://red568.github.io/2023/11/11/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/","excerpt":"","text":"测试测试大家东方红东方红阿斯顿回复","categories":[{"name":"Java","slug":"Java","permalink":"https://red568.github.io/categories/Java/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://red568.github.io/tags/%E6%B5%8B%E8%AF%95/"}]}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"},{"name":"Java","slug":"Java","permalink":"https://red568.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"测试","slug":"测试","permalink":"https://red568.github.io/tags/%E6%B5%8B%E8%AF%95/"}]}