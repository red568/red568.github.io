{"meta":{"title":"Red","subtitle":"�չ�һ��","description":"","author":"John Doe","url":"https://red568.github.io","root":"/"},"pages":[{"title":"about","date":"2023-11-11T14:13:12.000Z","updated":"2024-04-03T14:42:42.072Z","comments":true,"path":"about/index.html","permalink":"https://red568.github.io/about/index.html","excerpt":"","text":"关于我哈喽！欢迎来到我的世界~ 在这里，我会记录下自己的一些学习笔记、做题思路、复盘经历、个人感悟，这是我的小世界。 代码之路并不简单，难在坚持和钻研，我写这个博客的目的便是可以记录下自己的成长，并监督激励自己。 期待自己成为代码大佬的那天，那真是太酷啦！！！"},{"title":"about","date":"2024-04-01T06:11:35.000Z","updated":"2024-04-01T06:11:35.884Z","comments":true,"path":"about/index-1.html","permalink":"https://red568.github.io/about/index-1.html","excerpt":"","text":""}],"posts":[{"title":"算法练习--day2","slug":"算法练习-day2","date":"2024-04-07T07:57:37.000Z","updated":"2024-04-07T08:18:31.099Z","comments":true,"path":"2024/04/07/算法练习-day2/","link":"","permalink":"https://red568.github.io/2024/04/07/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-day2/","excerpt":"","text":"977.有序数组的平方题目： 分析： 最大值一定出现在两端，用双指针分别指向首尾两端，取平方的最大值放入新数组中最后倒序一下即可(或者直接倒序存入新数组也行) 1234567891011121314151617181920212223242526class Solution &#123; public int[] sortedSquares(int[] nums) &#123; int left=0; int right=nums.length-1; int[] newNums=new int[nums.length]; int[] temp=new int[nums.length]; int idx=0; while(left&lt;=right)&#123; int a=0; if(nums[left]*nums[left]&gt;=nums[right]*nums[right])&#123; a=nums[left]*nums[left]; left++; &#125;else&#123; a=nums[right]*nums[right]; right--; &#125; temp[idx]=a; idx++; &#125; idx=0; for(int i=temp.length-1;i&gt;=0;i--)&#123; newNums[idx++]=temp[i]; &#125; return newNums; &#125;&#125; 209.长度最小的子数组题目： 分析： 滑动窗口解决 （1）向右移动右指针直到窗口中的数值和&gt;&#x3D;target （2）再向右移动左指针直到窗口中的数值和不满足&gt;&#x3D;target 重复(1)(2)过程，直到右指针到达数值末尾，最终结果取最短窗口长度即可 123456789101112131415class Solution &#123;// 滑动窗口 public int minSubArrayLen(int s, int[] nums) &#123; int left = 0;//开始指针 int sum = 0; int result = Integer.MAX_VALUE;//result记录子序列长度 for (int right = 0; right &lt; nums.length; right++) &#123;//right是终止指针 sum += nums[right]; while (sum &gt;= s) &#123; result = Math.min(result, right - left + 1); sum -= nums[left++];//left指针向右移动 &#125; &#125; return result == Integer.MAX_VALUE ? 0 : result; &#125;&#125; 59.螺旋矩阵II题目： 分析： 方法1：由外向内，一圈一圈的向内循环，一共n&#x2F;2圈 填充上行从左到右 填充右列从上到下 填充下行从右到左 填充左列从下到上 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int[][] generateMatrix(int n) &#123; int loop = 0; // 控制循环次数 int start = 0; // 每次循环的开始点(start, start)，每经过一圈循环，向内部移动一下 int[][] res = new int[n][n]; int count = 1; // 定义填充数字 int i, j; //1.填写外围数字 while (loop++ &lt; n / 2) &#123;//一共有n/2个圆（循环） // 判断边界后，loop从1开始 //左闭右开 // 1.1 模拟上侧从左到右，j变化 for (j = start; j &lt; n - loop; j++) &#123; res[start][j] = count++; &#125; // 1.2 模拟右侧从上到下,i变化 for (i = start; i &lt; n - loop; i++) &#123; res[i][j] = count++; &#125; //1.3 模拟下侧从右到左，j变化 for (; j &gt;= loop; j--) &#123; res[i][j] = count++; &#125; // 1.4 模拟左侧从下到上，i变化 for (; i &gt;= loop; i--) &#123; res[i][j] = count++; &#125; //移动循环起始点 start++; &#125; //2.填写最中心那个数字 if (n % 2 == 1) &#123; res[start][start] = count; &#125; return res; &#125;&#125; 方法2：设置边界值，每次迭代完后移动边界值 此题的解题思路可参考： 54. 螺旋矩阵 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int[][] generateMatrix(int n) &#123; int l=0; int r=n-1; int t=0; int b=n-1; int[][] res=new int[n][n]; int count=1; while(true)&#123; //上侧 for(int i=l;i&lt;=r;i++)&#123; res[t][i]=count++; &#125; if(++t&gt;b) break; //右侧 for(int i=t;i&lt;=b;i++)&#123; res[i][r]=count++; &#125; if(--r&lt;l) break; //下侧 for(int i=r;i&gt;=l;i-- )&#123; res[b][i]=count++; &#125; if(--b&lt;t) break; //左侧 for(int i=b;i&gt;=t;i--)&#123; res[i][l]=count++; &#125; if(++l&gt;r) break; &#125; return res; &#125;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法练习—day1","slug":"算法练习—day1","date":"2024-04-03T13:49:55.000Z","updated":"2024-04-03T14:29:44.088Z","comments":true,"path":"2024/04/03/算法练习—day1/","link":"","permalink":"https://red568.github.io/2024/04/03/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E2%80%94day1/","excerpt":"","text":"704. 二分查找题目： 题目分析： 左右指针分别为[left,right]，每次都取中间元素和目标值比较，再移动左右指针即可 注意： (1) [left,right]是闭区间，在边界条件下mid可以取值为left或者right (2) 循环时的判断条件为 while(left&lt;&#x3D;right)，这里’&#x3D;’符号不可丢 (3) 为了防止数据多大，mid&#x3D;left+(right-left)&#x2F;2; (4) 二分法不仅可以用来查找值，还可以用来查值范围、用法很灵活，可以写个专题，这里留个坑之后填 代码： 27. 移除元素题目： 题目分析： 双指针法，用left记录留下值的数组末尾的下一位，也是新值将要插入的位置；right遍历值，如果指向值等于val则不做操作，指向值不等于val，则将该值赋值给left 注： 283. 移动零 和这道题的解题思路类似 代码：","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"测试文章","slug":"测试文章","date":"2023-11-11T14:16:15.000Z","updated":"2023-11-11T14:24:23.734Z","comments":true,"path":"2023/11/11/测试文章/","link":"","permalink":"https://red568.github.io/2023/11/11/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/","excerpt":"","text":"测试测试大家东方红东方红阿斯顿回复","categories":[{"name":"Java","slug":"Java","permalink":"https://red568.github.io/categories/Java/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://red568.github.io/tags/%E6%B5%8B%E8%AF%95/"}]}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://red568.github.io/categories/LeetCode/"},{"name":"Java","slug":"Java","permalink":"https://red568.github.io/categories/Java/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://red568.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"测试","slug":"测试","permalink":"https://red568.github.io/tags/%E6%B5%8B%E8%AF%95/"}]}